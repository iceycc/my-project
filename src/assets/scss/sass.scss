

// 1-css拓展 ==================================================================================================
// 1-1 嵌套功能
#main p {
  color: #00ff00;
  width: 97%;
  .redbox {
    background-color: #ff0000;
    color: #000000;
  }
}
#main {
  width: 97%;
  p,
  div {
    font-size: 2em;
    a {
      font-weight: bold;
    }
  }
  pre {
    font-size: 3em;
  }
}
// 1-2 父选择器
a { // 用 & 代表嵌套规则外层的父选择器
  font-weight: bold;
  text-decoration: none;
  &:hover {
    text-decoration: underline;
  }
  body.firefox & {
    font-weight: normal;
  }
}
#main { //编译后的 CSS 文件中 & 将被替换成嵌套外层的父选择器，如果含有多层嵌套，最外层的父选择器会一层一层向下传递
  color: black;
  a {
    font-weight: bold;
    &:hover {
      color: red;
    }
  }
}
#main { //& 必须作为选择器的第一个字符，其后可以跟随后缀生成复合的选择器
  color: black;
  &-sidebar {
    border: 1px solid;
  }
}
// 1-3 属性嵌套
.funky {
  font: {
    family: fantasy;
    size: 30em;
    weight: bold;
  }
}
.funky {
  font: 20px/24px {
    family: fantasy;
    weight: bold;
  }
}
// 1-4 占位符选择器 %foo (Placeholder Selectors: %foo)
// TODO:



// 2- 注释    ==================================================================================================
//  CSS 多行注释 /* */，以及单行注释 //，前者会 被完整输出到编译后的 CSS 文件中，而后者则不会
/* This comment is
 * several lines long.
 * since it uses the CSS comment syntax,
 * it will appear in the CSS output. */
body {
  color: black;
}
// These comments are only one line long each.
// They won't appear in the CSS output,
// since they use the single-line comment syntax.
a {
  color: green;
}

// 插值语句 (interpolation) 也可写进多行注释中输出变量值
$version: "1.2.3";
/* This CSS is generated by My Snazzy Framework version #{$version}. */
//==> 编译成
/* This CSS is generated by My Snazzy Framework version 1.2.3. */



// 3-SassScript   ==================================================================================================
//  在 CSS 属性的基础上 Sass 提供了一些名为 SassScript 的新功能。 SassScript 可作用于任何属性，允许属性使用变量、算数运算等额外功能。
//  通过 interpolation，SassScript 甚至可以生成选择器或属性名，这一点对编写 mixin 有很大帮助
//  3-1. Interactive Shell  ?????
    // $ sass -i
    // >> "Hello, Sassy World!"
    // "Hello, Sassy World!"
    // >> 1px + 1px + 1px
    // 3px
    // >> #777 + #777
    // #eeeeee
    // >> #777 + #888
    // white
//  3-2  变量 $ (Variables: $)
//变量支持块级作用域，嵌套规则内定义的变量只能在嵌套规则内使用（局部变量），不在嵌套规则内定义的变量则可在任何地方使用（全局变量）。
// 将局部变量转换为全局变量可以添加 !global 声明

$width: 5em;
#main {
  width: $width;
}

// 3-3. 数据类型 (Data Types)
    // SassScript 支持 6 种主要的数据类型：
    // 数字，1, 2, 13, 10px
    // 字符串，有引号字符串与无引号字符串，"foo", 'bar', baz
    // 颜色，blue, #04a3f9, rgba(255,0,0,0.5)
    // 布尔型，true, false
    // 空值，null
    // 数组 (list)，用空格或逗号作分隔符，1.5em 1em 0 2em, Helvetica, Arial, sans-serif
    // maps, 相当于 JavaScript 的 object，(key1: value1, key2: value2)
    // ==SassScript 也支持其他 CSS 属性值，比如 Unicode 字符集，或 !important 声明。然而Sass 不会特殊对待这些属性值，一律视为无引号字符串。

  // 3-3-1  字符串 Strings  
    // SassScript 支持两种字符串类型  
      // 无引号字符串  "Lucida Grande" 'http://sass-lang.com'；
      // 有引号字符串     sans-serif bold
      //  在编译css文件时 不会改变数据其类型  .只有一中情况例外,使用 #{} 时,将有引号的编译为无引号的字符串  
      @mixin firefox-message($selector) {
        body.firefox #{$selector}:before {
          content: "Hi, Firefox users!";
        }
      }

      @include firefox-message(".header");
  // 3-3-2  数组  lists
      //  主要处理 margin: 10px 15px 0 0  和 font-face: Helvetica, Arial, sans-serif
      // 相关函数 ：
      // nth 函数可以直接访问数组中的某一项
      // join 函数可以将多个数组连接在一起
      // append 函数可以在数组中添加新值
      // @each 指令能够遍历数组中的每一项

      // 1px 2px, 5px 6px
      //(1px 2px) (5px 6px)
  //  3-3-3  maps  对象
  //  3-3-4  颜色 Color

//  3-4  运算
    //  关系运算 <, >, <=, >= 也可用于数字运算，相等运算 ==, != 可用于所有数据类型
  //  3-4-1 数字运算
    //  (+, -, *, /, %)   如果必要会在不同单位间转换值
    p {
      width: 1in + 8pt;
    }
    // 3-4-1-1 触发运算
    // 以下三种情况 / 将被视为除法运算符号：
    // 如果值，或值的一部分，是变量或者函数的返回值
    // 如果值被圆括号包裹
    // 如果值是算数表达式的一部分
    p {
      font: 10px/8px; // Plain CSS, no division    ==>  font: 10px/8px;
      $width: 1000px;
      width: $width/2; // Uses a variable, does division   
      width: round(1.5)/2; // Uses a function, does division   ==>  width: 500px;
      height: (500px/2); // Uses parentheses, does division   ==>  height: 250px;
      margin-left: 5px+8px/2px; // Uses +, does division   ==?margin-left: 9px;
    }
    p {  // 如果需要使用变量，同时又要确保 / 不做除法运算而是完整地编译到 CSS 文件中，只需要用 #{} 插值语句将变量包裹。
      $font-size: 12px;
      $line-height: 30px;
      font: #{$font-size}/#{$line-height}; // ==>  font: 12px/30px;

    }
  //  3-4-2 颜色运算
      p {
        color: #010203+#040506; //计算 01 + 04 = 05 02 + 05 = 07 03 + 06 = 09，然后编译为  color: #050709;
      }
      //--
      p {
        color: #010203 * 2; // color: #020406; 

      }
      //--
      p {
        color: rgba(255, 0, 0, 0.75) + rgba(0, 255, 0, 0.75);   // ==>color: rgba(255, 255, 0, 0.75);
      }
      //--
      $translucent-red: rgba(255, 0, 0, 0.5);
      p {
        color: opacify($translucent-red, 0.3);  // color: rgba(255, 0, 0, 0.8);
        background-color: transparentize($translucent-red, 0.25); // background-color: rgba(255, 0, 0, 0.25); 
      }
      //--
      $translucent-red: rgba(255, 0, 0, 0.5);
      $green: #00ff00;
      div {
        filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr='#{ie-hex-str($green)}', endColorstr='#{ie-hex-str($translucent-red)}');
       // ==>filter: progid:DXImageTransform.Microsoft.gradient(enabled='false', startColorstr=#FF00FF00, endColorstr=#80FF0000);
      }
  // 3-4-3 字符串运算
      // + 可用于连接字符串
      p {
        cursor: e+-resize; // ==>    cursor: e-resize;
      }
      p:before {
        content: "Foo "+Bar; //  左侧为引号字符串   ==> content: "Foo Bar";
        font-family: sans- + "serif";  // 左侧为无引号字符串  ==>   font-family: sans-serif;
      }

      p {  // 运算表达式与其他值连用时，用空格做连接符：
        margin: 3px + 4px auto;   // ==> margin: 7px auto
      }

      p:before {  // 在有引号的文本字符串中使用 #{} 插值语句可以添加动态的值：
        content: "I ate #{5 + 10} pies!";   // ==> content: "I ate 15 pies!";
      }

      $value: null;   // 空的值被视作插入了空字符串
      p:before {
        content: "I ate #{$value} pies!";   // ==> content: "I ate pies!";
      }
  // 3-4-4 布尔值运算
        // SassScript 支持布尔型的 and or 以及 not 运算。
  // 3-4-5 数组运算   数组不支持任何运算方式，只能使用 list functions 控制。

// 3-5  圆括号 (Parentheses)
      p { //圆括号可以用来影响运算的顺序：
        width: 1em + (2em * 3);  // ==> width: 7em;
      }
// 3-6  函数 (Functions)
      p { // SassScript 定义了多种函数，有些甚至可以通过普通的 CSS 语句调用：
        color: hsl(0, 100%, 50%); // ==>   color: #ff0000; 
      }
  // 3-6-1  关键词参数 keyword arguments 
  // 键词参数给函数提供了更灵活的接口，以及容易调用的参数。
  // 关键词参数可以打乱顺序使用，如果使用默认值也可以省缺，
  // 另外，参数名被视为变量名，下划线、短横线可以互换使用。

      p {   // 虽然不够简明，但是阅读起来会更方便
        color: hsl($hue: 0, $saturation: 100%, $lightness: 50%);
      }
// 3-7 插值语句 #{} (Interpolation: #{})
      $name: foo;
      $attr: border;
      p.#{$name} {  // 通过 #{} 插值语句可以在选择器或属性名中使用变量
        #{$attr}-color: blue;
      }
      // 编译为 ==》
      p.foo {
        border-color: blue;
      }
      //--------
      p {   // 这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS
        $font-size: 12px;
        $line-height: 30px;
        font: #{$font-size}/#{$line-height};  // ==> font: 12px/30px; 
      }
// 3-8  & in SassScript
      .foo.bar .baz.bang,
      .bip.qux {
        $selector: &;    // (".foo.bar" ".baz.bang"), ".bip.qux"
      }

      @mixin does-parent-exist {
        @if & {
          &:hover {
            color: red;
          }
        }
        @else {
          a {
            color: red;
          }
        }
      }
// 3-9 变量定义 !default (Variable Defaults: !default)
      $content: "First content";
      $content: "Second content?" !default;
      $new_content: "First time reference" !default;
      #main {
        content: $content;    // ==> content: "First content";
        new-content: $new_content;   // ==> new-content: "First time reference";
      }

      $content: null;
      $content: "Non-null content" !default;
      #main {   // 变量是 null 空值时将视为未被 !default 赋值。
        content: $content;    // ==>   content: "Non-null content";
      }

// 4-@-Rules 与指令 (@-Rules and Directives)
// 4-1  @import
  // Sass 拓展了 @import 的功能，允许其导入 SCSS 或 Sass 文件。
  // 被导入的文件将合并编译到同一个 CSS 文件中，另外，被导入的文件中所包含的变量或者混合指令 (mixin) 都可以在导入的文件中使用。

    // 通常，@import 寻找 Sass 文件并将其导入，但在以下情况下，@import 仅作为普通的 CSS 语句，不会导入任何 Sass 文件。
    //   文件拓展名是 .css；
    //   文件名以 http:// 开头；
    //   文件名是 url()；
    //   @import 包含 media queries。
  //如果不在上述情况内，文件的拓展名是 .scss 或 .sass，则导入成功。没有指定拓展名，Sass 将会试着寻找文件名相同，拓展名为 .scss 或 .sass 的文件并将其导入。
      @import "foo.scss";
      @import "foo"; //都会导入文件 foo.scss

      @import "foo.css";
      @import "foo" screen;
      @import "http://foo.com/bar";
      @import url(foo);
      //==>
      @import "foo.css";
      @import "foo" screen;
      @import "http://foo.com/bar";
      @import url(foo);

      @import "rounded-corners", "text-shadow";  //允许同时导入多个文件

      $family: unquote("Droid+Sans");  //导入文件也可以使用 #{ } 插值语句，但不是通过变量动态导入 Sass 文件，只能作用于 CSS 的 url() 导入方式
      @import url("http://fonts.googleapis.com/css?family=\#{$family}");
      // 编译为==>
      @import url("http://fonts.googleapis.com/css?family=Droid+Sans");
  // 4-1-1  分音 (Partials)
      // 如果需要导入 SCSS 或者 Sass 文件，但又不希望将其编译为 CSS，只需要在文件名前添加下划线，
      // 这样会告诉 Sass 不要编译这些文件，但导入语句中却不需要添加下划线

      // 例如 将文件命名为 _colors.scss，便不会编译 _colours.css 文件
      @import "colors"; // 导入的其实是 _colors.scss 文件  
      // 不可以同时存在添加下划线与未添加下划线的同名文件，添加下划线的文件将会被忽略。
  // 4-1-2. 嵌套 @import
      // 假设 example.scss 文件包含以下样式：
      .example {
        color: red;
      }
      // 然后导入到 #main 样式内
      #main {
        @import "example";
      }
      // 将会被编译为  ==>
      #main .example {
        color: red;
      }
      // 不可以在混合指令 (mixin) 或控制指令 (control directives) 中嵌套 @import。
// 4-2 @media
      //  @media 指令与 CSS 中用法一样
      //  只是增加了一些内容 ： 
      // 允许其在 CSS 规则中嵌套。如果 @media 嵌套在 CSS 规则内，编译时，@media 将被编译到文件的最外层，包含嵌套的父选择器
        .sidebar {
          width: 300px;
          @media screen and (orientation: landscape) {
            width: 500px;
          }
        }
        //  编译为 ==> 
        .sidebar {
          width: 300px;
        }
        @media screen and (orientation: landscape) {
          .sidebar {
            width: 500px;
          }
        }
      // @media 的 queries 允许互相嵌套使用，编译时，Sass 自动添加 and
        @media screen {
          .sidebar {
            @media (orientation: landscape) {
              width: 500px;
            }
          }
        }
        // ==>
        @media screen and (orientation: landscape) {
          .sidebar {
            width: 500px;
          }
        }
      //@media 甚至可以使用 SassScript（比如变量，函数，以及运算符）代替条件的名称或者值：
        $media: screen;
        $feature: -webkit-min-device-pixel-ratio;
        $value: 1.5;
        @media #{$media} and ($feature: $value) {
          .sidebar {
            width: 500px;
          }
        }
        // 编译为 ==>
        @media screen and (-webkit-min-device-pixel-ratio: 1.5) {
          .sidebar {
            width: 500px;
          }
        }
// 4-3 @extend  相同样式抽离！！ 继承！！！
    // <div class="error seriousError">
    //   Oh no! You've been hacked!
    // </div>
    //  传统样式如下
    .error {
      border: 1px #f00;
      background-color: #fdd;
    }
    .seriousError {
      border-width: 3px;
    }
    // ==》 用sass可以这样写的
    .error {
      border: 1px #f00;
      background-color: #fdd;
    }
    .seriousError {
      @extend .error;  // 继承
      border-width: 3px;
    }

  // ---
    .error.intrusion {
      background-image: url("/image/hacked.png");
    }
  // 4-3-1. How it Works
    //@extend 的作用是将重复使用的样式 (.error) 延伸 (extend) 给需要包含这个样式的特殊样式（.seriousError）
    .error {
      border: 1px #f00;
      background-color: #fdd;
    }
    .error.intrusion {
      background-image: url("/image/hacked.png");
    }
    .seriousError {
      @extend .error;
      border-width: 3px;
    }
    // 编译为 ==>  001

    .error,
    .seriousError {
      border: 1px #f00;
      background-color: #fdd;
    }
    .error.intrusion,
    .seriousError.intrusion {
      background-image: url("/image/hacked.png");
    }
    .seriousError {
      border-width: 3px;
    }
    //当合并选择器时，@extend 会很聪明地避免无谓的重复，.seriousError.seriousError 将编译为 .seriousError，不能匹配任何元素的选择器
  // 4-3-2. 延伸复杂的选择器 (Extending Complex Selectors)
      // Sass 允许延伸任何定义给单个元素的选择器，比如 .special.cool，a:hover 或者 a.user[href^="http://"] 等
      .hoverlink {
        @extend a:hover;
      }
      a:hover {
        text-decoration: underline;
      }
      //  ==> 
      a:hover,
      .hoverlink {
        text-decoration: underline;
      }
  // 4-3-3. 多重延伸 (Multiple Extends)
      .error {
        border: 1px #f00;
        background-color: #fdd;
      }

      .attention {
        font-size: 3em;
        background-color: #ff0;
      }

      .seriousError {
        @extend .error;
        @extend .attention;
        // @extend .error, .attention;  //多重延伸可以使用逗号分隔选择器名
        border-width: 3px;
      }
      //  编译为 ==> 
      .error,
      .seriousError {
        border: 1px #f00;
        background-color: #fdd;
      }

      .attention,
      .seriousError {
        font-size: 3em;
        background-color: #ff0;
      }

      .seriousError {
        border-width: 3px;
      }
  // 4-3-4.继续延伸 (Chaining Extends)
      .error {
        border: 1px #f00;
        background-color: #fdd;
      }
      .seriousError {
        @extend .error;
        border-width: 3px;
      }
      .criticalError {
        @extend .seriousError;
        position: fixed;
        top: 10%;
        bottom: 10%;
        left: 10%;
        right: 10%;
      }
      //  编译为 ==>
      .error,
      .seriousError,
      .criticalError {
        border: 1px #f00;
        background-color: #fdd;
      }
      .seriousError,
      .criticalError {
        border-width: 3px;
      }
      .criticalError {
        position: fixed;
        top: 10%;
        bottom: 10%;
        left: 10%;
        right: 10%;
      }
  // 4-3-5.选择器列 (Selector Sequences)
      // 暂时不可以将选择器列 (Selector Sequences)，比如 .foo .bar 或 .foo + .bar，延伸给其他元素，但是，却可以将其他元素延伸给选择器列
      #fake-links .link {
        @extend a;
      }
      a {
        color: blue;
        &:hover {
          text-decoration: underline;
        }
      }
      // 编译为 ==>
      a,
      #fake-links .link {
        color: blue;
      }

      a:hover,
      #fake-links .link:hover {
        text-decoration: underline;
      }
  // 4-3-5.1  合并选择器列 (Merging Selector Sequences)
    //当两个列 (sequence) 合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：
      #admin .tabbar a {
        font-weight: bold;
      }
      #demo .overview .fakelink {
        @extend a;
      }
      //  编译为 ==>
      #admin .tabbar a,
      #admin .tabbar #demo .overview .fakelink,
      #demo .overview #admin .tabbar .fakelink {
        font-weight: bold;
      }
    //如果两个列 (sequence) 包含了相同的选择器，相同部分将会合并在一起，其他部分交替输出。在下面的例子里，两个列都包含 #admin，输出结果中它们合并在了一起：
      #admin .tabbar a {
        font-weight: bold;
      }

      #admin .overview .fakelink {
        @extend a;
      }
      // 编译为 ==>
      #admin .tabbar a,
      #admin .tabbar .overview .fakelink,
      #admin .overview .tabbar .fakelink {
        font-weight: bold;
      }
// 4-3-6  @extend-Only 选择器 (@extend-Only Selectors)
      // TODO:  7.3.6. @extend-Only 选择器 (@extend-Only Selectors)  https://www.sass.hk/docs/#t7-3-6









      
















    





























































































